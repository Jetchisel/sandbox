# ============================================================================================ #
#: Title           : sdb                                                                       #
#: Sypnosis        : sdb [OPTIONS]... [QUERY]...                                               #
#: Date Created    : Sat 25 Nov 2017 10:10:47 AM +08  /  Sat Nov 25 02:10:47 UTC 2017          #
#: Last Edit       : Mon 13 Aug 2018 13:05:49 PM +08  /  Mon Aug 13 05:05:49 UTC 2018          #
#: License         : MIT                                                                       #
#: Version         : 3.0.1                                                                     #
#: Maintainer      : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : Log bash_history in a database (A fork of dbhist.sh by Dennis Gladkikh)   #
#: Options         : [abcdehlmnoprsuvwABEMS?]                                                  #
#: Home Page       : https://github.com/Jetchisel/sdb                                          #
#: ExtComm         : base64,date,dd,whoami,realpath,rm,sqlite3,tput,uname                      #
#: Copyright       : Jason V. Ferrer 2017-2018                                                 #
# ============================================================================================ #

################################################################################################
# The MIT License                                                                              #
# SPDX short identifier: MIT                                                                   #
#                                                                                              #
# Further resources on the MIT License                                                         #
# Copyright 2017 Denis Gladkikh (https://www.outcoldman.com/en/archive/2017/07/19/dbhist/)     #
# Copyright 2017-2018 Jason V. Ferrer based on above.                                          #
#                                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy                 #
# of this software and associated documentation files (the "Software"), to deal                #
# in the Software without restriction, including without limitation the rights                 #
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                    #
# copies of the Software, and to permit persons to whom the Software is                        #
# furnished to do so, subject to the following conditions:                                     #
#                                                                                              #
# The above copyright notice and this permission notice shall be included in                   #
# all copies or substantial portions of the Software.                                          #
#                                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                #
# SOFTWARE.                                                                                    #
#                                                                                              #
#==============================================================================================#
# Configuration:                                                                               #
#   Add the following entry in your shell rc file, e.g. "$HOME/.bashrc"                        #
#                                                                                              #
#   set -o history                                                                             #
#   HISTSIZE=1000                                                                              #
#   HISTTIMEFORMAT="%s "                                                                       #
#   HISTFILE=$HOME/.bash_history                                                               #
#   HISTCONTROL=ignorespace:erasedups                                                          #
#   SDB_HISTORY=true                                                                           #
#   SDB_DATABASE=$HOME/.bash_history.sqlite.                                                   #
#                                                                                              #
#   Change The value of SDB_HISTORY from "true" to "false" to disable sdb.                     #
#   Change the value of SDB_DATABASE to something/somewhere else for multi-user set up.        #
#                                                                                              #
# Using the script:                                                                            #
#   if the script is in the current pwd.                                                       #
#   source ./sdb                                                                               #
#                                                                                              #
#   if the script is somewhere else.                                                           #
#   source /path/to/somewhere/else/sdb                                                         #
################################################################################################

# ******************************************************************************************** #
#                       Enable extglob, just in case it is not enabled.                        #
# ******************************************************************************************** #

if ! builtin shopt -q extglob; then
  builtin shopt -s extglob
fi

# ******************************************************************************************** #
#                             The scriptname without the pathname.                             #
# ******************************************************************************************** #

__sdb_name_=${BASH_SOURCE##*/}

# ******************************************************************************************** #
#                    Warn function to print error messages to stderr.                          #
# ******************************************************************************************** #

__sdb_warn_() {
  builtin printf '%s: %s\n%s\n' "$__sdb_name_" "$@" >&2
}

# ******************************************************************************************** #
#              Check if bash version is lower than 4, exit with an error if true.              #
# ******************************************************************************************** #

if (( BASH_VERSINFO[0] < 4 )); then ##: If bash version is lower than 4.
  __sdb_warn_ 'This function requires bash 4.0 or newer' 'Please update to a more recent bash.' ##: Print this error message
  builtin return 1 ##: Exit with an error.
fi

# ******************************************************************************************** #
#       Function for , exit so sdb can capture the commands before it can be executed.         #
# ******************************************************************************************** #
##: Just append the commands to the ~/.bash_history file using the builtin history so sdb can parse it.
exit() {
  builtin history -s -- exit "$@"
}
##: See the __sdb__executioner function
# ******************************************************************************************** #
#                               Function to show the help menu.                                #
# ******************************************************************************************** #

____ShowHelp____() {
  builtin trap '> "/dev/fd/$tempfile"' return
  builtin trap 'builtin exit 1' 1 2 3 15

  if ! builtin type -P less >/dev/null; then
    __sdb_warn_ "less is either not installed or it is not in your PATH" "bye!"
    builtin return 1
  fi

builtin exec {tempfile}<<-'EOF'
USAGE: sdb [OPTIONS]... [QUERY]...

A bash shell function that records bash_history in a sqlite3 database.
Recorded commands can be queried and executed as well.

Without any options/arguments the default is to show the recent commands
if there is/are any in the current session. (sdb commands excluded by default.)

OPTIONS:
  -c, --common-info                 Implies -hudl.
  -?, --help                        Show this help.
  -o, --off-pager                   Disable the pager.
  -s, --self                        Include history about sdb.
  -u, --user [word]                 Show user that matches word.
  -h, --host [word]                 Show the host that matches word.
  -E, --execute-id [n]              Execute the command with the nth id.
  -l, --last-status                 Show the exit status of the commands.
  -e, --end-with [word]             Match only commands that ends with word.
  -b, --begin-with [word]           Match only commands that starts with word.
  -d, --directory                   Show the working directory of the commands.
  -v, --verbose                     Verbose output (show actual sqlite3 command).
  -M, --mode-line                   Print the output as if ".mode line" is enabled.
  -w, --with-word [word]            Match commands with word from beginning to end.
  -p, --path [dir]                  Show commands executed inside the directory dir.
  -a, --all                         Include history of all sessions. Not only current.
  -S, --shell                       Access to the sqlite3 shell and load the shell database.
  -r, --recurse-path [dir]          Show commands executed inside and under the directory dir.
  -t, --time-search [start],[end]   Search commands from start date to end date, GNU date syntax.
  -m, --max-count [n+]              N numbers of latest commands to show. Use + for maximum value.
  -A, --ascending                   Sort the output in an ascending manner (Descending is the default).
  -n, --numeric-status [n+]         Show commands that exited with the nth status or + if greater than zero.

A newly open shell does not have  any commands to show unless the -a option is specified which
defaults to 100 lines, unless the -m option is specified.

The date/time format is in Unix epoch time. GNU date has some option to convert that into human
readable format. It also has an option which allows you to say things like today, now, yesterday
-1 month, etc. The -t or --time-search make use of this words. The format is "startdate, end date"
It should be separated by a comma. The start date should always come first followed by the end date.
Both arguments needs to be quoted together, otherwise the shell will see it as two arguments.

Examples of searching by date.

   search between yesterday and now.

    "yesterday, now"

   search between yesterday and an hour ago

   "-1 day, -1 hour"

   search between a year ago and today.

   "1 year ago, today"

   search between last tuesday and a minute ago.

   "last tuesday, -1 minute"

See the manual for more info on GNU date(1).

For maximum query use + instead of [n] when the -m or --max-count is specified.
The value of [n] becomes 999999999999999999, Which translates to:

    Nine hundred ninety-nine quadrillion.
    Nine hundred ninety-nine trillion.
    Nine hundred ninety-nine billion.
    Nine hundred ninety-nine million.
    Nine hundred ninety-nine thousand.
    Nine hundred ninety-nine.

Long options that takes an argument also supports the following syntax:

    --option=argument

Short options that does not take an argument can be joined as one option:

    -adlsv

Both short and long option can be used as well.

    --option=argument -acv -m+

Redirect the output to a file use the redirection "greater than" > sign.

    sdb -vcam+ > file

The PAGER and EDITOR  environment  variables is used/accepted when doing a
search/query/edit for the commands. Except for -? and --help option. PAGER
defaults to  whatever the system is using. EDITOR defaults to vim if empty.

    PAGER=kate sdb -vcam+

    EDITOR=nano sdb -E 101

Some editors like gvim does not work by default without some options.
create a function first.

    gvim() { builtin command -p gvim -f "$@"; }

    PAGER=gvim sdb -vcam+

THE ORDER OF COLUMNS
   1rst column: ID column, increment of all the executed commands.
   2nd  column: Number of times the commands has been executed.
   3rd  column: Specified by -[hu], shows the user & host.
   4rth column: Date and time of the executed commands.
   5th  column: Specified by the -l option shows the exit status.
   6th  column: Specified by the -d option shows the pwd.
   last column: Commands, separated by a > from the path column.

NOTE
   As far as the shell is concern When it comes to the exit status of the given
   command, 0 is a success and the rest are a failure. But not all commands that
   exited with a nonzero is a failure per se. Likewise  not all  commands that
   exited with  zero is a success. Consult  the documentation of the program in
   question.

SEE ALSO
       sqlite3(1), signal(7), date(1)
       https://www.sqlite.org/index.html
       The "EXIT STATUS" section from bash(1).

AUTHOR
     Jason V. Ferrer <jetchisel@opensuse.org>
EOF

"${PAGER:-less}" "/dev/fd/$tempfile"
builtin return
}

# ******************************************************************************************** #
#                                      The magic starts.                                       #
# ******************************************************************************************** #

if "${SDB_HISTORY:-true}"; then   ##: Kind of session ID, allows to see only commands executed in this terminal session
  if ! builtin type -P dd >/dev/null; then ##: if dd is not installed; then exit with an error message; fi
    builtin printf '%s: %s\n' "$__sdb_name_" "dd is either not installed or it is not in your PATH!" >&2
    builtin return 127
  elif ! builtin type -P base64 >/dev/null; then ##: if base64 is not installed; then exit with an error message; fi
    builtin printf '%s: %s\n' "$__sdb_name_" "base64 is either not installed or it is not in your PATH!" >&2
    builtin return 127
  fi
  __sdb_salt=$(builtin command -p dd if=/dev/urandom bs=32 count=1 2>/dev/null | builtin command -p base64)
  ##:This allows us to verify existence of .bash_history.sqlite file only once
  __sdb_initialized=0
  ##: Keep the previous folder, this how we keep the PWD for commands like `cd ...`
  __sdb_pwd=$(builtin pwd)
  __sdb_pwd=${__sdb_pwd//$'\n'/\\n}
  __sdb_oldpwd+=("$__sdb_pwd")
  ##: Variables to check/set if the database has been deleted or truncated.
  __sdb_empty_data_base=0
  __sdb_does_not_exists=0
  ##: Get location of the database file, default location is under `$HOME/.bash_history.sqlite`
  __sdb_file=${SDB_DATABASE:-/home/jetchisel/Projects/shared_history_database/bash_history.sqlite}
  ##: Execute command on sqlite3 with ~/.bash_history.sqlite database plus more option/args via "$@"
  if ! builtin type -P sqlite3 >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" 'sqlite3 is either not installed or it is not in your PATH' >&2
    builtin return 127
  fi
  __sdb_sqlite() {
    builtin command -p sqlite3 "$__sdb_file" "$@"
  }

  ##: Initialize sdb file, create table
  __sdb_init() {
    builtin local sql='CREATE TABLE history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hist_id INTEGER,
    cmd TEXT,
    epoch INTEGER,
    ppid INTEGER,
    exit_status INTEGER,
    user_hosts TEXT,
    pwd TEXT,
    salt TEXT
    );
    CREATE TABLE directories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    epoch INTEGER,
    user_hosts TEXT,
    cwd TEXT,
    salt TEXT
    );'

    if [[ ! -f "$__sdb_file" ]]; then
      __sdb_sqlite <<< "$sql"
    fi
  }

  if ! builtin type -P whoami >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "whoami is either not installed or it is not in your PATH!" >&2
    builtin return 127
  elif ! builtin type -P uname >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "uname is either not installed or it is not in your PATH!" >&2
    builtin return 127
  fi
  __sdb_logname_=$(builtin command -p whoami)
  __sdb_hostname_=$(builtin command -p uname -n)
  __sdb_user_host=${__sdb_logname_:-Anonymous}@${__sdb_hostname_:-Nohost}

  if [[ -f $__sdb_file ]]; then
    __sdb_sqlite <<-EOF
	INSERT INTO directories(
	epoch,
	user_hosts,
	cwd,
	salt
	)
	VALUES(
	"$(builtin command -p date -d 'now' '+%s')",
	"$__sdb_user_host",
	"${__sdb_pwd//\"/\"\"}",
	"$__sdb_salt"
	);
	EOF
  fi
  ##: Execute it with bash.
  __sdb_prompt() {
    ##Last_Command=$?
    builtin history -a
    builtin history -c
    builtin history -r

    if ((!__sdb_initialized)); then
      __sdb_init
      __sdb_initialized=1
      builtin return
    fi

    if ((!__sdb_does_not_exists)); then
      if [[ ! -f $__sdb_file ]]; then
        __sdb_warn_ "It looks like $__sdb_file does not exists, please verify it." "run: file $__sdb_file"
        __sdb_does_not_exists=1
        builtin return 1
      fi
    fi

    if ((!__sdb_empty_data_base)); then
      if [[ ! -s $__sdb_file  ]]; then
        __sdb_warn_ "It looks like $__sdb_file is empty, please verify it." "run: file $__sdb_file"
        __sdb_empty_data_base=1
        builtin return 1
      fi
    fi

    if [[ -n $COMP_LINE ]]; then
      builtin return
    fi

    builtin local IFS=
    builtin local num=
    builtin local pwd=
    builtin local minus=
    builtin local epoch=
    builtin local total0=
    builtin local total1=
    builtin local regexp2=
    builtin local logname=
    builtin local command=
    builtin local hostname=
    builtin local command__=
    builtin local previous_cmd=
    builtin local previous_cwd=
    builtin local recent_command=
    builtin local latest_hist_id=
    builtin local uncaptured_pwd=
    builtin local uncaptured_num=
    builtin local uncaptured_reg=
    builtin local previous_epoch=
    builtin local uncaptured_salt=
    builtin local uncaptured_ppid=
    builtin local history2_output=
    builtin local history1_output=
    builtin local uncaptured_epoch=
    builtin local uncaptured_command=
    builtin local previous_user_hosts=
    pwd=$(builtin pwd) ##: Assign a default value to pwd just in case ${__sdb_oldpwd} is exactly as $__sdb_pwd then the pwd column is EMTPY!
    pwd=${pwd//$'\n'/\\n}
    __sdb_pwd=$(builtin pwd)
    __sdb_pwd=${__sdb_pwd//$'\n'/\\n}
    if [[ ${__sdb_oldpwd[-1]} != $__sdb_pwd ]]; then
      pwd=${__sdb_oldpwd[-1]}
      __sdb_oldpwd+=("$__sdb_pwd")
    fi
    __sdb_sqlite <<-EOF
	INSERT INTO directories(
	epoch,
	user_hosts,
	cwd,
	salt
	)
	VALUES(
	"$(builtin command -p date -d 'now' '+%s')",
	"$__sdb_user_host",
	"${__sdb_pwd//\"/\"\"}",
	"$__sdb_salt"
	);
	EOF

# ******************************************************************************************** #
#  A hack to capture commands like "exec rm file" or "source  ~/.bashrc" by parsing history 2  #
# ******************************************************************************************** #
##: An option to fix it would be to create a function for cd,pushd or popd and send the pwd to another database/table and parse/compare it.
    regexp='[[:space:]]+([[:digit:]]+)[[:space:]]+([[:digit:]]+)[[:space:]](.+)' ##: The output of history 1 is '  627  1511580643 recent_command_goes_here'
    uncaptured_reg='source|exec[[:space:]]+[[:alpha:]]+.*'
    while builtin read -r history2_output
      IFS=$'\n' builtin read -rd '' history1_output; do ##: Set IFS to a newline, use reads -d option, so multiline command such a heredocs is captured.
      builtin return
    done < <(builtin history 2)
    ##: Use BASH_REMATCH and =~ to split the output of history 2 into 3 parts.
    if [[ $history2_output =~ $regexp ]]; then
      uncaptured_num=${BASH_REMATCH[1]}      ##: num=627
      uncaptured_epoch=${BASH_REMATCH[2]}    ##: epoch=1511580643
      uncaptured_command=${BASH_REMATCH[3]}  ##: command=recent_command_goes_here
      if [[ $uncaptured_command =~ $uncaptured_reg ]]; then
        while builtin read -r uncaptured_salt
          builtin read -r uncaptured_ppid
          builtin read -r previous_user_hosts
          builtin read -r previous_cmd
          builtin read -r previous_epoch
          builtin read -ru8 previous_cwd; do
          break
        done < <(
          __sdb_sqlite ".sep \n" "SELECT salt,ppid,user_hosts,cmd,epoch FROM history WHERE
          user_hosts = '$__sdb_user_host' AND epoch <= '$uncaptured_epoch' ORDER BY ID DESC LIMIT 1;"
          ) 8< <(
            __sdb_sqlite "SELECT cwd FROM directories WHERE
            user_hosts = '$__sdb_user_host' AND epoch <= '$uncaptured_epoch' ORDER BY ID DESC LIMIT 1;"
            )
        if [[ $previous_cmd != $uncaptured_command ]]; then
     __sdb_sqlite <<-END
	INSERT INTO history(
	hist_id, epoch, cmd, ppid, exit_status, user_hosts, pwd, salt
	)
	VALUES(
	"$uncaptured_num",
	"$uncaptured_epoch",
	"${uncaptured_command//\"/\"\"}",
	"$uncaptured_ppid",
	"0",
	"$__sdb_user_host",
	"${previous_cwd//\"/\"\"}",
	"$uncaptured_salt"
	);
	END
        fi
      fi
    fi

# ******************************************************************************************** #
#                                      Parsing history 1.                                      #
# ******************************************************************************************** #
    ##: Use BASH_REMATCH and =~ to split the output of history 1 into 3 parts.
    if [[ $history1_output =~ $regexp ]]; then
      num=${BASH_REMATCH[1]}      ##: num=627
      epoch=${BASH_REMATCH[2]}    ##: epoch=1511580643
      command=${BASH_REMATCH[3]}  ##: command=recent_command_goes_here
    fi

    if [[ $command = 'exit '* ]]; then         ##: If command is exit with an argument.
      if [[ ${command#* } = +([0-9]) ]]; then  ##: check the argument if it is an integer
        Last_Command=${command#* }             ##: Assign the value of it is an integer
      else
        Last_Command=2                         ##: If not then assign the value of 2
      fi                                       ##: to Last_Command variable. exit status column.
    fi                                         ##: Which is the default exit status of builtin exit with that situation.
                               ##: Put the builtin commands that affects sdb in this Executioner function so sdb can capture
    __sdb__executioner__() {   ##: them in the database before executing the commands
      builtin local dirname=
      builtin local basename=
      if [[ $command = 'exit '* ]]; then ##: If command is exit with an arguments
        dirname=${command% *}            ##: split the commands into 2 parts
        basename=${command#* }           ##: dirname=exit basename=[n]
        builtin "$dirname" "$basename"   ##: Execute the builtin with dirname and basename.
      elif [[ $command = 'exit' ]]; then
        builtin exit                     ##: Otherwise just exit.
      fi
    }

# ******************************************************************************************** #
#             Insert data into the database using a while read loop and a heredoc.             #
# ******************************************************************************************** #

    latest_hist_id=$(( $(__sdb_sqlite 'select hist_id from history order by id desc limit 1;') + 1 ))
    ##: Use the builtin date command to avoid emtpy epoch column entry no matter what.
    while builtin read -r command__ <&8; do
      __sdb_sqlite <<-END
	INSERT INTO history(
	hist_id, epoch, cmd, ppid, exit_status, user_hosts, pwd, salt
	)
	VALUES(
	"${num:-"$latest_hist_id"}",
	"${epoch:-"$(builtin command -p date -d 'now' '+%s')"}",
	"${command__//\"/\"\"}",
	"$PPID",
	"${Last_Command:-777}",
	"$__sdb_user_host",
	"${pwd//\"/\"\"}",
	"$__sdb_salt"
	);
	END
    done 8<<< "${command:-HISTTIMEFORMAT=\"%s \"}" || builtin return ##: Add HISTTIMEFORMAT to avoid empty cmd column entry whatever happens.
##: If this message appears then most likely $HISTTIMEFORMAT is not in epoch "%s "
    __sdb__executioner__ ##: Run the executioner now that commands are captured in the database.
  }

  sdb() {

     builtin local all=0
     builtin local end=0
     builtin local pwd=0
     builtin local zero=0
     builtin local self=0
     builtin local path=0
     builtin local rpath=0
     builtin local begin=0
     builtin local max=100
     builtin local ascend=0
     builtin local execute=0
     builtin local verbose=0
     builtin local offpager=0
     builtin local OnlyUser=0
     builtin local OnlyHost=0
     builtin local modeline=0
     builtin local exit_stat=0
     builtin local user_host=0
     builtin local whole_line=0
     builtin local __sdb_edit=0
     builtin local time_search=0
     builtin local numeric_status=0
     builtin local G=
     builtin local R=
     builtin local dir0=
     builtin local dir1=
     builtin local dir2=
     builtin local user0=
     builtin local user1=
     builtin local user2=
     builtin local stat0=
     builtin local stat1=
     builtin local stat2=
     builtin local pwd_q=
     builtin local menus=
     builtin local answer=
     builtin local location=
     builtin local UserOnly=
     builtin local HostOnly=
     builtin local optstring=
     builtin local separator=
     builtin local User_Host=
     builtin local query_end=
     builtin local pathquery=
     builtin local rpathquery=
     builtin local ExitStatus=
     builtin local query_begin=
     builtin local query_whole=
     builtin local execute_var=
     builtin local time_search0=
     builtin local time_search1=
     builtin local time_search2=
     builtin local execute_var0=
     builtin local both_user_host=
     builtin local __sdb_execute_var=
     builtin local first_sql_commands=
     builtin local numeric_status_value=
     builtin local sorting=DESC
     builtin local name=$__sdb_name_
     builtin local comm0='----------------+'
     builtin local comm1='   COMMAND      |'
     builtin local comm2='----------------+'
     builtin local def0='+------------+--------+---------------------+'
     builtin local def1='|     ID     | COUNT  |      DATE/TIME      |'
     builtin local def2='+------------+--------+---------------------+'
     builtin declare -a __sdb_opt
     ##: If tput is installed then assign the color to the variable; fi
     if builtin type -P tput >/dev/null; then
       G=$(builtin command -p tput bold)
       R=$(builtin command -p tput sgr0)
     fi

# ******************************************************************************************** #
# Getops from scratch by D.J. Mills, https://github.com/e36freak/templates/blob/master/options #
# ******************************************************************************************** #
     ##: option string, for short options, very much like getopts, any option followed by a ':' takes a required arg
     optstring=acdlosvAMSb:e:h:m:n:u:w:r:t:p:E:

     builtin unset options

     while (($#)); do
       case $1 in
         -[!-]?*)  ##: if option is of type -ab, since the while loop will process each option/argument one by one.
           [[ $1 = -[[:digit:]]* ]] && options+=("$1") && shift  ##: <-- ADDED BY JETCHISEL, ignore digit with a leading dash -, proceed to the next.
           for ((i=1; i<${#1}; i++)); do ##: loop over each character starting with the second
             c=${1:i:1}
             options+=("-$c") ##: add current char to options
             if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then ##: if option takes a required argument, and it's not the last char, make the rest of the string its argument
               options+=("${1:i+1}")
               builtin break
             fi
           done
           ;;
         --?*=*) options+=("${1%%=*}" "${1#*=}");;  ##: if option is of type --foo=bar, split on first '='
         --) options+=(--endopts);; ##: add --endopts for --
         *) options+=("$1");; ##: otherwise, nothing special
       esac
       builtin shift
     done
     ##: set new positional parameters to altered options
     builtin set -- "${options[@]}"

     builtin unset options

# ******************************************************************************************** #
#   If first option is not empty and it does not start with a dash then exit with an error.    #
# ******************************************************************************************** #

     [[ -n $1 && $1 != -?* ]] && {
       __sdb_warn_ "invalid option -- '$1'" "Try '$__sdb_name_ --help'"
       builtin return 1
     }

# ******************************************************************************************** #
#                          Parse the command line arguments/options.                           #
# ******************************************************************************************** #

     while [[ $1 = -?* ]]; do ##: loop through the options, starts with a dash.
       case $1 in             ##: -?* means it can be a short option, the ? means one character
         --shell|-S)          ##: the ? means it can be followed by any string, by another dash
           __sdb_sqlite       ##: or by a single string like -- or -a
           builtin return
           ;;
         --help|-\?)
           ____ShowHelp____
           builtin return
           ;;
         --max-count|-m)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "Max count requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif ! [[ $1 = +([0-9]) || $1 = "+" ]]; then ##: If $1 is not a digit nor a + sign.
             __sdb_warn_ "max count -- '$G$1$R' should be a number or a + sign!" "Try '$__sdb_name_ --help'"
             builtin return 1 ##: Exit/return with an error.
           fi
           if [[ $1 = + ]]; then ##: If value of $1 is a + sign.
             max=999999999999999999 ##: then the value of max becomes 18 9's.
           else
             max=$1
           fi
           ;;
         --ascending|-A)
           ascend=1
           ;;
         --all|-a)
           all=1
           ;;
         --common-info|-c)
           pwd=1
           user_host=1
           exit_stat=1
           ;;
         --last-status|-l)
           exit_stat=1
           ;;
         --mode-line|-M)
           modeline=1
           ;;
         --self|-s)
           self=1
           ;;
         --begin-with|-b)
           builtin shift
           begin=1
           if ((whole_line)); then
             __sdb_warn_ 'conflicting options specified!' "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           if [[ -z $1 ]]; then
             __sdb_warn_ "begin requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           query_begin=$1
           ;;
         --host|-h)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "host requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           user_host=1
           OnlyHost=1
           HostOnly=%@${1}
           ;;
         --time-search|-t)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "Time requires two values, separated by a comma!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           time_search=1
           time_search0=$1
           time_search1=$(builtin command -p date -d"${time_search0%,*}" "+%s") || builtin return
           time_search2=$(builtin command -p date -d"${time_search0#*,}" "+%s") || builtin return
           ;;
         --user|-u)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "user requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           user_host=1
           OnlyUser=1
           UserOnly=${1}@%
           ;;
         --end-with|-e)
           builtin shift
           end=1
           if ((whole_line)); then
             __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           if [[ -z $1 ]]; then
             __sdb_warn_ "end requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           query_end=$1
           ;;
         --off-pager|-o)
           offpager=1
           ;;
         --recurse-path|-r)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "path requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif [[ $1 = @('.'|'./'|'..'|'../') ]]; then
             if builtin type -P realpath >/dev/null; then
               rpathquery=$(builtin command -p realpath -- "$1")
             else
               __sdb_warn_ "Could not resolve path $G$1$R" "realpath is either not installed or it is not in your PATH"
               builtin return 1
             fi
           else
             rpathquery=$1
           fi
           rpath=1
           pwd=1
           ;;
         --path|-p)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "path requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif [[ $1 = @('.'|'./'|'..'|'../') ]]; then
             if builtin type -P realpath >/dev/null; then
               pathquery=$(builtin command -p realpath -- "$1")
             else
               __sdb_warn_ "Could not resolve path $G$1$R" "realpath is either not installed or it is not in your PATH"
               builtin return 1
             fi
           else
             pathquery=$1
           fi
           pwd=1
           path=1
           ;;
         --verbose|-v)
           verbose=1
           ;;
         --with-word|-w)
           builtin shift
           whole_line=1
           if ((begin || end)); then
             __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           if [[ -z $1 ]]; then
             __sdb_warn_ "word requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           query_whole=$1
           ;;
         --execute-id|-E)
           builtin shift
           execute=1
           if [[ -z $1 ]]; then
             __sdb_warn_ "id requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif [[ $1 != +([0-9]) ]]; then
             __sdb_warn_ "id -- '$G$1$R' should be a number!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           execute_var=$1
           ;;
         --directory|-d)
           pwd=1
           ;;
         --numeric-status|-n)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "status requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif ! [[  $1 = +([0-9]) || $1 = + ]]; then
             __sdb_warn_ "status requires an integer or a + sign!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           exit_stat=1
           numeric_status=1
           numeric_status_value=$1
           ;;
         --endopts)
           builtin shift
           builtin break
           ;;
         *)
            __sdb_warn_ "invalid option -- '$G$1$R'" "Try '$__sdb_name_ --help'"
            builtin return 1
           ;;
       esac
       builtin shift
     done

# ******************************************************************************************** #
#            The separator character to print, depending on the value of $DISPLAY.             #
# ******************************************************************************************** #

     if [[ -n $DISPLAY ]]; then
       separator=" ▶  "
     else
       separator=" >  "
     fi

# ******************************************************************************************** #
# Run the command with the corresponding ID, with the all time favorite builtin command: EVAL  #
# ******************************************************************************************** #

     if ((execute)); then
       execute_var0=$(__sdb_sqlite "select cmd,exit_status from history where id in ( $execute_var );")
       if [[ -z $execute_var0 ]]; then
         __sdb_warn_ "id -- \`$G$execute_var$R' is either out of range, or it has no command." "Try another number instead!" >&2
         builtin return 1
       fi

       __sdb_opt=(
         "[Execute the command]${separator// } \`$G${execute_var0%"|"*}$R'" "[Previous exit_status]${separator// } \`$G${execute_var0##*"|"}$R'"
         "[Inside the current directory]${separator// } \`$G$(builtin pwd)$R'" "${G}1${R}) Yes, execute now." "${G}2${R}) No, abort command."
         "${G}3${R}) No, print ALL info to stdout only." "${G}4${R}) No, edit command first with the EDITOR." "[${G}1-4${R}]$G${separator// }$R "
       )

        while builtin :; do
          builtin printf -v menus '\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n%s%s' "${__sdb_opt[@]}"
          builtin read -rp "$menus" -n 1 answer
           case $answer in
             1)
               builtin echo   ##: Test if the command is a directory and autocd is enabled and skip it since autocd prints 'cd -- /path'
               { [[ -d "${execute_var0%"|"*}" ]] && builtin shopt -q autocd ; } || builtin printf '%s\n' "${execute_var0%"|"*}"
               builtin history -s "${execute_var0%"|"*}"
               builtin eval "${execute_var0%"|"*}" || builtin return
               builtin return
               ;;
             2) builtin return
               ;;
             3)
               builtin echo  ##: Show ALL the info about the id given via -E
               __sdb_sqlite ".mode line" "select * from history where id = $execute_var;"
               builtin return
               ;;
             4)
               builtin echo
               __sdb_edit=1
               builtin break
               ;;
             *)
               builtin printf '\n\n'
               __sdb_warn_ "invalid option -- '$G$answer$R'" "Try '[${G}1 2 3 4${R}]'"
               builtin return 1
               ;;
           esac
       done

       if ((__sdb_edit)); then ##: WARNING ZE EVAL!! :)
         builtin trap '> "/dev/fd/$tempfile"' return
         builtin trap 'builtin exit 1' 1 2 3 15
					builtin exec {tempfile}<<-EOF
					EOF
         builtin printf '%s\n' "${execute_var0%"|"*}" > "/dev/fd/$tempfile"
         "${EDITOR:-vim}" "/dev/fd/$tempfile"
         while IFS= builtin read -u9 -r __sdb_evalcommands; do
           builtin history -s "$__sdb_evalcommands"
           { [[ -d "$__sdb_evalcommands" ]] && builtin shopt -q autocd ; } || builtin printf '%s\n' "$__sdb_evalcommands"
           builtin eval "$__sdb_evalcommands" || builtin return
         done 9< "/dev/fd/$tempfile"
         builtin return
       fi
     fi

# ******************************************************************************************** #
#      First sqlite3 command, just to print out a formatted output separated by a pipe.        #
# ******************************************************************************************** #

     if ((exit_stat)); then
       ExitStatus="substr('      '||max(exit_status),-6) ||
       ' | '||"
       stat0='--------+'
       stat1=' STATUS |'
       stat2='--------+'
     fi

     if ((user_host)); then
       User_Host="substr('             '||max(user_hosts),-20)||
       ' | '||"
       user0='----------------------+'
       user1='      USER@HOST       |'
       user2='----------------------+'
     fi

     if ((pwd)); then
       pwd_q="pwd || \"$separator\" ||"
     fi

     if ((modeline)); then  ##: DON'T put this assignment in ONE-LINE it will BREAK THE SQLITE SYNTAX!!!
       first_sql_commands=".mode line
         SELECT * FROM history WHERE 1"
     else  ##: DON'T put this assignment in ONE-LINE it will BREAK THE SQLITE SYNTAX!!!
       first_sql_commands="
        SELECT
        substr('           '||max(id),-12) ||
          ' | ' ||
          substr('      '||count(*),-6) ||
          ' | ' ||
          datetime(max(epoch), 'unixepoch', 'localtime') ||
          ' | ' ||
          $User_Host
          $ExitStatus
          $pwd_q
        cmd
        FROM history
        WHERE 1"
      fi

# ******************************************************************************************** #
#                  Assign the sqlite3 commands inside the sql_commands array.                  #
# ******************************************************************************************** #

     builtin declare -a sql_commands
     sql_commands+=("$first_sql_commands")

# ******************************************************************************************** #
#     Sqlite3 commands to be executed depending on the args/options given by the user.         #
# ******************************************************************************************** #

     if ((!all)); then
       sql_commands+=("AND (salt=\"$__sdb_salt\" AND ppid=\"$PPID\")")
     fi

     if ((!self)); then
       sql_commands+=("AND (cmd != 'sdb' AND cmd NOT LIKE 'sdb %')")
     fi

     if ((OnlyUser)); then
       sql_commands+=("AND (user_hosts LIKE \"$UserOnly\")")
     fi

     if ((OnlyHost)); then
       sql_commands+=("AND (user_hosts LIKE \"$HostOnly\")")
     fi

     if ((begin)); then
       query_begin=${query_begin//\"/\"\"}
       query_begin=$query_begin%
       sql_commands+=("AND (cmd LIKE \"$query_begin\" ESCAPE '\')")
     fi

     if ((end)); then
       query_end=${query_end//\"/\"\"}
       query_end=%$query_end
       sql_commands+=("AND (cmd LIKE \"$query_end\" ESCAPE '\')")
     fi

     if ((whole_line)); then
       query_whole=${query_whole//\"/\"\"}
       query_whole=%$query_whole%
       sql_commands+=("AND (cmd LIKE \"$query_whole\" ESCAPE '\')")
     fi

     if ((path)); then
       if [[ -n $rpathquery ]]; then
         __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
         builtin return 1
       fi
       pathquery=${pathquery//\"/\"\"}
       sql_commands+=("AND (pwd = \"$pathquery\")")
     fi

     if ((rpath)); then
        if [[ -n $pathquery ]]; then
          __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
          builtin return 1
        fi
        rpathquery=${rpathquery//\"/\"\"}
       sql_commands+=("AND (pwd LIKE \"$rpathquery%\" ESCAPE '\')")
     fi

     if ((time_search)); then
       sql_commands+=("AND (epoch between $(builtin command -p date -d"${time_search0%,*}" "+%s") and $(builtin command -p date -d"${time_search0#*,}" "+%s"))")
     fi

     if ((numeric_status)); then
       if [[ $numeric_status_value = + ]]; then
         sql_commands+=("AND (exit_status > '0')")
       else
         sql_commands+=("AND (exit_status = $numeric_status_value)")
       fi
     fi

     sql_commands+=("GROUP BY cmd,exit_status,user_hosts")
     if ((pwd)); then  ##: If -d|--directory is the option specified.
       sql_commands+=(,pwd)
       dir0='----------------+'
       dir1="   DIRECTORY    |${separator// }"
       dir2='----------------+'
       comm1='    COMMAND    |'
     fi

     if ((ascend)); then
       sorting=ASC
     fi

     sql_commands+=("ORDER BY max(id) $sorting LIMIT $max;")
     ##: if the -v|--verbose is the option specified.
     __sdb__main_funct__() {
       if ((verbose)); then ##: Print the actual sqlite3 commands
         builtin printf '%s%s%s\n' "sqlite3 "  "${__sdb_file% *}" "${sql_commands[*]}"
         builtin printf '\n'
       fi
       ##: Print the headers depending on the option/arguments beside the default header.
       if ((!modeline)); then
         builtin printf '%s\n%s\n%s\n' "$def0$user0$stat0$dir0$comm0" "$def1$user1$stat1$dir1$comm1" "$def2$user2$stat2$dir2$comm2"
       fi
       ##: Insert/feed the contents of the array sql_commands into sqlite3 as one argument only, using '%s '
       __sdb_sqlite < <(builtin printf '%s ' "${sql_commands[@]}") || builtin return
       builtin return
     }

     if ((!offpager)); then
       builtin trap '> "/dev/fd/$tempfile"' return
       builtin trap 'builtin exit 1' 1 2 3 15
				builtin exec {tempfile}<<-EOF
				EOF
       __sdb__main_funct__ > "/dev/fd/$tempfile" 2>&1 || builtin return
       if [[ $PAGER  = less ]]; then  ##: If pager is less which is the default for openSUSE
         builtin command -p "$PAGER" -Ss "/dev/fd/$tempfile" || builtin return  ##: invoke it with the builitn command -p and add the -Ss flag
         builtin return
       fi
       "${PAGER:-less}" "/dev/fd/$tempfile" || builtin return
       builtin return
     fi

     __sdb__main_funct__
     builtin return
  }

fi

# ******************************************************************************************** #
#          assign the function __sdb_prompt to the bash variable PROMPT_COMMAND.               #
# ******************************************************************************************** #

if [[ $PROMPT_COMMAND != *__sdb_prompt* ]]; then
  PROMPT_COMMAND="__sdb_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
fi

# ******************************************************************************************** #
#   A hack to send an error message when the script was invoke via the likes of 'bash ./sdb'   #
# ******************************************************************************************** #

(builtin return 2>/dev/null) || {
  __sdb_warn_ "To use '$__sdb_name_'" "Run: source $BASH_SOURCE"
  (builtin return 2>/dev/null)
}
# vim:ft=sh
# ============================================================================================ #
#                                   >>> END OF SCRIPT <<<                                      #
# ============================================================================================ #
